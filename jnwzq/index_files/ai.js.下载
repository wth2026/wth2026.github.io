
// AIçŠ¶æ€åˆ†åˆ«å­˜å‚¨
let aiThinking = {
    'black-zhangcheng': false,
    'black-skill5': false,
    'black-ziqi': false,
    'black-wangjinbao': false,
    'white-zhangcheng': false,
    'white-skill5': false,
    'white-ziqi': false,
    'white-wangjinbao': false
};

let aiDecisionHistory = {
    'black-zhangcheng': [],
    'black-skill5': [],
    'black-ziqi': [],
    'black-wangjinbao': [],
    'white-zhangcheng': [],
    'white-skill5': [],
    'white-ziqi': [],
    'white-wangjinbao': []
};

// ç»Ÿä¸€çš„AIé…ç½® - æ‰€æœ‰AIä½¿ç”¨ç›¸åŒç­–ç•¥
const UNIFIED_AI_CONFIG = {
    skillProbability: {
        skill1: 0.7,
        skill3: 0.5,
        skill5: 0.4,
        skill6: 1,
        skill7: 0.4,
        skill9: 0.3,
        skill11: 0.4,
        skill12: 0.4
    },
    useSkillProbability: 0.6,
    aggression: 0.6,
    defense: 0.6,
    randomness: 0.2
};

// 8ä¸ªAIè§’è‰²ä½¿ç”¨ç›¸åŒçš„é…ç½®
const AI_CONFIGS = {
    'black-zhangcheng': UNIFIED_AI_CONFIG,
    'black-skill5': UNIFIED_AI_CONFIG,
    'black-ziqi': UNIFIED_AI_CONFIG,
    'black-wangjinbao': UNIFIED_AI_CONFIG,
    'white-zhangcheng': UNIFIED_AI_CONFIG,
    'white-skill5': UNIFIED_AI_CONFIG,
    'white-ziqi': UNIFIED_AI_CONFIG,
    'white-wangjinbao': UNIFIED_AI_CONFIG
};

// 8ä¸ªAIè§’è‰²çš„ç‹¬ç«‹è¯­æ–™åº“
const AI_DIALOGUES = {
    'black-zhangcheng': [
        "å“ªæœ‰ä»€åˆ¹æµ·å‘€ï¼Œæ²¡æœ‰ä»€åˆ¹æµ·ï¼",
        "å¤ªè€èµ–äº†ï¼",
        "ç‹—å±ä¸         é€šï¼ï¼",
        "ä½ ç®¡è¿™ä¸ªå«ä¸‹äº”å­æ£‹ï¼Ÿï¼",
        "åˆ«å¼„ï¼Œæˆ‘è¿™æ˜¯æ–°è£¤å­ï¼",
        "äº”å­æ£‹çš„çœŸè°›å°±ä¸åœ¨ä½ ä»¬æ‰‹ä¸Šï¼",
        "ä½ æ¢¦åˆ°å“ªå¥è¯´å“ªå¥å•Šï¼Ÿ",
        "æ¥å‘€ï¼Œæˆ‘å¿…é¡»è¦å½“å…¨å›½ç¬¬ä¸€ï¼Œå°±ç®—ç”¨ä½ ä»¬çš„æ–¹å¼ï¼Œæˆ‘ä¹Ÿèƒ½èµ¢ï¼",
        "ä½ ä»¬ä¸è¿‡æ˜¯æ‰“ç€äº”å­æ£‹çš„åå·æ‹›æ‘‡æ’éª—ç½¢äº†ï¼Œä½ ä»¬æ ¹æœ¬å°±ä¸é…ä¸‹äº”å­æ£‹ï¼"
    ],
    'black-skill5': [
        "ä½ è¿™ä¸ªç•œç”Ÿï¼",
        "å¤–ç»ƒç­‹éª¨çš®ï¼Œå†…ç»ƒäº”å­æ£‹ï¼",
        "å¤–ç»ƒç­‹éª¨çš®ï¼Œç»ƒçš„æ˜¯æ‰‹åˆ€ï¼",
        "å†…ç»ƒäº”å­æ£‹ï¼Œç»ƒçš„æ˜¯æŠ½è±¡ï¼",
        "å¦‚æœä½ ä¸‹æ£‹æ˜¯ä¸ºäº†èµ¢çš„è¯ï¼Œé‚£ä½ å’Œé‚£äº›ä¸‹æ£‹çš„æœ‰ä»€ä¹ˆåŒºåˆ«ï¼",
        "æ‰“çš„ä¸ºå¸ˆå±æ»šå°¿æµ",
        "å­©å­ï¼Œä½ ç°åœ¨æ˜ç™½äº”å­æ£‹çš„çœŸè°›äº†å—ï¼Ÿ",
        "ä½ éª‚è€äºº",
        "ä½ ä¸è¦çªå­çªï¼"
    ],
    'black-ziqi': [
        "ä½ å°±æ˜¯ä¸ªä¸‹æ£‹çš„ï¼Œé‚£ä½ å°±æ˜¯ä¸ªä¸‹æ£‹çš„ï¼",
        "å±…ç„¶åˆ›é€ æ–°è¯ï¼Œè¿™å¯æ˜¯æœ€ç»ˆçš„å¥¥ä¹‰~~~",
        "æ—¢ç„¶è¿™æ ·åˆ«æ€ªæˆ‘ä¸å®¢æ°”å•¦~~~",
        "æƒ³æŒ‘æˆ˜æˆ‘å¸ˆçˆ¶ï¼Œå…ˆä»æˆ‘çš„å°¸ä½“ä¸Šè·¨è¿‡å»ï¼",
        "æˆ‘è¦ä¸ºè€å¸ˆæŠ¥ä»‡ï¼"
    ],
    'black-wangjinbao': [
        "æˆ‘åé«˜é“æ¥çš„ï¼",
        "ä½ å¤ªè¿‡åˆ†äº†ï¼ŒæŠŠæˆ‘å¾’å¼Ÿå½“è‡­ç‹—ä¸€æ ·ç©è€ã€‚",
        "ä»–æ˜¯ç‹—å—ä»–æ˜¯ï¼Ÿï¼",
        "ä½ å¤šä¹…æ²¡æœ‰åœ¨ä¸‹äº”å­æ£‹çš„æ—¶å€™ï¼Œåˆå”±åˆè·³äº†ï¼Ÿ"
    ],
    'white-zhangcheng': [
        "å“ªæœ‰ä»€åˆ¹æµ·å‘€ï¼Œæ²¡æœ‰ä»€åˆ¹æµ·ï¼",
        "å¤ªè€èµ–äº†ï¼",
        "ç‹—å±ä¸         é€šï¼ï¼",
        "ä½ ç®¡è¿™ä¸ªå«ä¸‹äº”å­æ£‹ï¼Ÿï¼",
        "åˆ«å¼„ï¼Œæˆ‘è¿™æ˜¯æ–°è£¤å­ï¼",
        "äº”å­æ£‹çš„çœŸè°›å°±ä¸åœ¨ä½ ä»¬æ‰‹ä¸Šï¼",
        "ä½ æ¢¦åˆ°å“ªå¥è¯´å“ªå¥å•Šï¼Ÿ",
        "æ¥å‘€ï¼Œæˆ‘å¿…é¡»è¦å½“å…¨å›½ç¬¬ä¸€ï¼Œå°±ç®—ç”¨ä½ ä»¬çš„æ–¹å¼ï¼Œæˆ‘ä¹Ÿèƒ½èµ¢ï¼",
        "ä½ ä»¬ä¸è¿‡æ˜¯æ‰“ç€äº”å­æ£‹çš„åå·æ‹›æ‘‡æ’éª—ç½¢äº†ï¼Œä½ ä»¬æ ¹æœ¬å°±ä¸é…ä¸‹äº”å­æ£‹ï¼"
    ],
    'white-skill5': [
        "ä½ è¿™ä¸ªç•œç”Ÿï¼",
        "å¤–ç»ƒç­‹éª¨çš®ï¼Œå†…ç»ƒäº”å­æ£‹ï¼",
        "å¤–ç»ƒç­‹éª¨çš®ï¼Œç»ƒçš„æ˜¯æ‰‹åˆ€ï¼",
        "å†…ç»ƒäº”å­æ£‹ï¼Œç»ƒçš„æ˜¯æŠ½è±¡ï¼",
        "å¦‚æœä½ ä¸‹æ£‹æ˜¯ä¸ºäº†èµ¢çš„è¯ï¼Œé‚£ä½ å’Œé‚£äº›ä¸‹æ£‹çš„æœ‰ä»€ä¹ˆåŒºåˆ«ï¼",
        "æ‰“çš„ä¸ºå¸ˆå±æ»šå°¿æµ",
        "å­©å­ï¼Œä½ ç°åœ¨æ˜ç™½äº”å­æ£‹çš„çœŸè°›äº†å—ï¼Ÿ",
        "ä½ éª‚è€äºº",
        "ä½ ä¸è¦çªå­çªï¼"
    ],
    'white-ziqi': [
        "ä½ å°±æ˜¯ä¸ªä¸‹æ£‹çš„ï¼Œé‚£ä½ å°±æ˜¯ä¸ªä¸‹æ£‹çš„ï¼",
        "å±…ç„¶åˆ›é€ æ–°è¯ï¼Œè¿™å¯æ˜¯æœ€ç»ˆçš„å¥¥ä¹‰~~~",
        "æƒ³æŒ‘æˆ˜æˆ‘å¸ˆçˆ¶ï¼Œå…ˆä»æˆ‘çš„å°¸ä½“ä¸Šè·¨è¿‡å»ï¼",
        "æ—¢ç„¶è¿™æ ·åˆ«æ€ªæˆ‘ä¸å®¢æ°”å•¦~~~",
        "æˆ‘è¦ä¸ºè€å¸ˆæŠ¥ä»‡ï¼"
    ],
    'white-wangjinbao': [
        "æˆ‘åé«˜é“æ¥çš„ï¼",
        "ä½ å¤ªè¿‡åˆ†äº†ï¼ŒæŠŠæˆ‘å¾’å¼Ÿå½“è‡­ç‹—ä¸€æ ·ç©è€ã€‚",
        "ä»–æ˜¯ç‹—å—ä»–æ˜¯ï¼Ÿï¼",
        "ä½ å¤šä¹…æ²¡æœ‰åœ¨ä¸‹äº”å­æ£‹çš„æ—¶å€™ï¼Œåˆå”±åˆè·³äº†ï¼Ÿ"
    ]
};

// åˆå§‹åŒ–AIåŠŸèƒ½

function initAI() {
    console.log("åˆå§‹åŒ–AIåŠŸèƒ½");
    
    const blackTypeSelect = document.getElementById('black-player-type');
    const whiteTypeSelect = document.getElementById('white-player-type');
    
    if (blackTypeSelect && whiteTypeSelect) {
        updatePlayerType(0, blackTypeSelect.value);
        updatePlayerType(1, whiteTypeSelect.value);
    }
    
    console.log("AIåˆå§‹åŒ–å®Œæˆ");
}

// æ›´æ–°ç©å®¶ç±»å‹
function updatePlayerType(playerIndex, type) {
    playerTypes[playerIndex] = type;
    
    const nameInput = playerIndex === 0 ? 
        document.getElementById('black-player-name') : 
        document.getElementById('white-player-name');
    
    // æ§åˆ¶AIæ€è€ƒæ¨¡å—çš„æ˜¾ç¤º
    const aiThinkingContainer = document.getElementById('ai-thinking-container');
    const hasAI = isAI(playerTypes[0]) || isAI(playerTypes[1]);
    
    if (aiThinkingContainer) {
        aiThinkingContainer.style.display = hasAI ? 'block' : 'none';
    }
    
    if (isAI(type)) {
        const aiName = getAIName(type);
        nameInput.value = aiName;
        nameInput.readOnly = true;
    } else {
        nameInput.readOnly = false;
        nameInput.value = playerIndex === 0 ? 'å­æ£‹' : 'å¼ å‘ˆ';
    }
    
    if (typeof updatePlayerNames === 'function') {
        updatePlayerNames();
    }
    
    // å¦‚æœæ¸¸æˆå·²ç»å¼€å§‹ä¸”å½“å‰ç©å®¶æ˜¯AIï¼Œè§¦å‘AIç§»åŠ¨
    if (gameStarted && !gameOver && currentPlayer === playerIndex + 1 && isAI(playerTypes[currentPlayer - 1])) {
        setTimeout(() => {
            aiMakeMove();
        }, 300);
    }
}

// AIè½å­é€»è¾‘
function aiMakeMove() {
    const aiType = playerTypes[currentPlayer - 1];
    
    console.log(`AIç§»åŠ¨å¼€å§‹: ${aiType}, å½“å‰ç©å®¶: ${currentPlayer}`);
    
    // æ£€æŸ¥æ˜¯å¦æ˜¯æœ‰æ•ˆçš„AIç±»å‹
    if (!isAI(aiType)) {
        console.log(`æ— æ•ˆçš„AIç±»å‹: ${aiType}, å–æ¶ˆAIç§»åŠ¨`);
        return;
    }
    
    // æ£€æŸ¥æ˜¯å¦è¢«æŠ€èƒ½å°é”
    if (skill12TimerActive || skill2TimerActive) {
        aiThinking[aiType] = false;
        updateAIThinkingLog("AIå›åˆè¢«æŠ€èƒ½è·³è¿‡ï¼Œæ— éœ€æ€è€ƒ");
        return;
    }
    
    if (!gameStarted || gameOver || aiThinking[aiType]) return;
    
    aiThinking[aiType] = true;
    const playerName = playerNames[currentPlayer - 1];
    
    updateStatusDisplay(`${playerName}å›åˆ`, "AIæ€è€ƒä¸­...");
    
    // æ˜¾ç¤ºAIæ€è€ƒå®¹å™¨
    const aiThinkingContainer = document.getElementById('ai-thinking-container');
    if (aiThinkingContainer) {
        aiThinkingContainer.style.display = 'block';
    }
    
    // è®°å½•AIæ€è€ƒå¼€å§‹
    updateAIThinkingLog(`ğŸ¤– ${playerName}å¼€å§‹æ€è€ƒ...`);
    
    // æ¨¡æ‹ŸAIæ€è€ƒæ—¶é—´
    setTimeout(() => {
        if (gameOver) {
            aiThinking[aiType] = false;
            return;
        }
        
        if (skill12TimerActive || skill2TimerActive) {
            aiThinking[aiType] = false;
            updateAIThinkingLog("AIå›åˆè¢«æŠ€èƒ½è·³è¿‡ï¼Œæ€è€ƒä¸­æ–­");
            return;
        }
        
        try {
            const decision = aiDecideAction(aiType);
            let randomDialogue;
            
            if (aiDecisionHistory[aiType]) {
                aiDecisionHistory[aiType].push({
                    turn: moveCount[0] + moveCount[1],
                    decision: decision
                });
            }

            const dialogues = AI_DIALOGUES[aiType];
            if (dialogues && dialogues.length > 0) {
                randomDialogue = dialogues[Math.floor(Math.random() * dialogues.length)];
            } else {
                randomDialogue = 'ä¸æƒ³è¯´è¯';
            }

            if (decision && decision.type === 'move') {
                const position = `${String.fromCharCode(65 + decision.col)}${decision.row + 1}`;
                const content = randomDialogue+'\n'+`${playerName}å†³å®šè½å­äº ${position} ç†ç”±: ${decision.reason || 'æœ€ä½³è½å­ä½ç½®'}`;
                updateAIThinkingLog(content);
                
                setTimeout(() => {
                    if (gameStarted && !gameOver && typeof placePiece === 'function') {
                        placePiece(decision.row, decision.col);
                    }
                    aiThinking[aiType] = false;
                }, 300);
                
            } else if (decision && decision.type === 'skill') {
                const skillNames = {
                    1: 'é£æ²™èµ°çŸ³', 3: 'åŠ›æ‹”å±±è¥¿', 5: 'å¼ å…´æœ', 
                    7: 'ä¿æ´ä¸Šé—¨', 9: 'ä¸¤æåè½¬', 11: 'æ“’æ“’æ‹¿æ‹¿',
                    12: 'See You Again'
                };
                const skillName = skillNames[decision.skill] || `æŠ€èƒ½${decision.skill}`;
                addActionLog(`ä½¿ç”¨${skillName}`, true);
                const content = randomDialogue+'\n'+`${playerName}å†³å®šä½¿ç”¨æŠ€èƒ½ ${skillName}\nç†ç”±: ${decision.reason || 'æˆ˜æœ¯éœ€è¦'}`;
                updateAIThinkingLog(content);
                
                setTimeout(() => {
                    if (gameStarted && !gameOver) {
                        useAISkill(decision.skill, aiType);
                    }
                    aiThinking[aiType] = false;
                }, 300);
            } else {
                aiThinking[aiType] = false;
            }

        } catch (error) {
            console.error('AIå†³ç­–è¿‡ç¨‹ä¸­å‡ºé”™:', error);
            aiThinking[aiType] = false;
        }
    }, 300);
}

// AIå†³ç­–ï¼šå†³å®šæ˜¯è½å­è¿˜æ˜¯ä½¿ç”¨æŠ€èƒ½
function aiDecideAction(aiType) {
    const config = AI_CONFIGS[aiType] || UNIFIED_AI_CONFIG;
    const useSkillProbability = config.useSkillProbability || 0.6;
    
    // è·å–å¯ç”¨æŠ€èƒ½
    const availableSkills = getAvailableSkills(aiType).filter(skill => [1,2,3,4,5,6,7,8,9,10,11,12].includes(skill));
    
    // æ£€æŸ¥æ˜¯å¦æœ‰å¯ç”¨çš„æŠ€èƒ½
    if (availableSkills.length > 0 && Math.random() < useSkillProbability) {
        const selectedSkill = selectAISkill(availableSkills, aiType);
        if (selectedSkill) {
            return { 
                type: 'skill', 
                skill: selectedSkill.skill,
                reason: selectedSkill.reason
            };
        }
    }
    
    // å¦åˆ™è½å­
    const move = getBestMove(aiType);
    return { 
        type: 'move', 
        row: move.row, 
        col: move.col,
        reason: move.reason || 'æœ€ä½³è½å­ä½ç½®'
    };
}

// æ›´æ–°AIæ€è€ƒæ—¥å¿—
function updateAIThinkingLog(content) {
    const aiThinkingLog = document.getElementById('ai-thinking-log');
    if (aiThinkingLog) {
        aiThinkingLog.textContent = content;
    }
}

// è·å–AIå¯ç”¨çš„æŠ€èƒ½
function getAvailableSkills(aiType) {
    const availableSkills = [];
    const aiIndex = currentPlayer - 1;
    
    if (typeof skill1Active === 'undefined' || typeof skill1Used === 'undefined') return availableSkills;
    
    // æŠ€èƒ½1: é£æ²™èµ°çŸ³
    if (skill1Active[aiIndex] && !skill1Used[aiIndex] && (!skill11Blocked || !skill11Blocked[aiIndex])) {
        availableSkills.push(1);
    }
    
    // æŠ€èƒ½3: åŠ›æ‹”å±±è¥¿
    if (skill3Used && !skill3Used[aiIndex]) {
        availableSkills.push(3);
    }
    
    // æŠ€èƒ½5: å¼ å…´æœ
    if (skill5Used && !skill5Used[aiIndex]) {
        availableSkills.push(5);
    }
    
    // æŠ€èƒ½7: ä¿æ´ä¸Šé—¨
    if (skill7Active && skill7Active[aiIndex] && !skill7Used[aiIndex]) {
        availableSkills.push(7);
    }
    
    // æŠ€èƒ½9: ä¸¤æåè½¬
    if (skill9Used && !skill9Used[aiIndex]) {
        availableSkills.push(9);
    }
    
    // æŠ€èƒ½11: æ“’æ“’æ‹¿æ‹¿
    if (skill11Active && skill11Active[aiIndex] && !skill11Used[aiIndex]) {
        availableSkills.push(11);
    }
    
    // æŠ€èƒ½12: See You Again
    if (skill12Active && skill12Active[aiIndex] && !skill12Used[aiIndex]) {
        availableSkills.push(12);
    }
    
    return availableSkills;
}

// AIé€‰æ‹©æŠ€èƒ½
function selectAISkill(availableSkills, aiType) {
    const skillValues = [];
    const config = AI_CONFIGS[aiType] || UNIFIED_AI_CONFIG;
    
    for (const skill of availableSkills) {
        let evaluation = { value: 0, reason: '' };
        
        switch (skill) {
            case 1: evaluation = evaluateSkill1(aiType); break;
            case 3: evaluation = evaluateSkill3(aiType); break;
            case 5: evaluation = evaluateSkill5(aiType); break;
            case 7: evaluation = evaluateSkill7(aiType); break;
            case 9: evaluation = evaluateSkill9(aiType); break;
            case 11: evaluation = evaluateSkill11(aiType); break;
            case 12: evaluation = evaluateSkill12(aiType); break;
        }
        
        const baseProbability = (config.skillProbability && config.skillProbability[`skill${skill}`]) || 0.2;
        evaluation.value *= baseProbability;
        
        const randomness = config.randomness || 0.2;
        evaluation.value *= (1 + Math.random() * randomness);
        
        skillValues.push({ 
            skill, 
            value: evaluation.value,
            reason: evaluation.reason
        });
    }
    
    // æŒ‰ä»·å€¼æ’åºï¼Œé€‰æ‹©ä»·å€¼æœ€é«˜çš„æŠ€èƒ½
    skillValues.sort((a, b) => b.value - a.value);
    
    if (skillValues.length > 0 && skillValues[0].value > 0.1) {
        return {
            skill: skillValues[0].skill,
            reason: skillValues[0].reason
        };
    }
    
    return null;
}

// è¯„ä¼°æŠ€èƒ½1: é£æ²™èµ°çŸ³
function evaluateSkill1(aiType) {
    let maxValue = 0;
    let enemyCount = 0;
    const config = AI_CONFIGS[aiType] || UNIFIED_AI_CONFIG;
    const aggression = config.aggression || 0.6;
    
    for (let i = 0; i < BOARD_SIZE; i++) {
        for (let j = 0; j < BOARD_SIZE; j++) {
            if (board[i][j] === currentPlayer) {
                const count = countEnemyPiecesInRange(i, j, SKILL_RANGE);
                const value = count * 0.3 * aggression;
                
                if (value > maxValue) {
                    maxValue = value;
                    enemyCount = count;
                }
            }
        }
    }
    
    return {
        value: maxValue,
        reason: enemyCount > 0 ? `å¯æ¸…é™¤${enemyCount}ä¸ªæ•Œæ–¹æ£‹å­` : 'æ— åˆé€‚ç›®æ ‡'
    };
}

// è¯„ä¼°æŠ€èƒ½3: åŠ›æ‹”å±±è¥¿
function evaluateSkill3(aiType) {
    const enemyPlayer = currentPlayer === 1 ? 2 : 1;
    let maxValue = 0;
    let reason = 'æ— é‡è¦ä½ç½®å¯ç ´å';
    const config = AI_CONFIGS[aiType] || UNIFIED_AI_CONFIG;
    const defense = config.defense || 0.6;
    
    for (let i = 0; i < BOARD_SIZE; i++) {
        for (let j = 0; j < BOARD_SIZE; j++) {
            if (board[i][j] === 0 && !isPositionBroken(i, j) && !isPositionBlocked(i, j)) {
                let value = 0;
                let posReason = '';
                
                if (isImportantPosition(i, j, enemyPlayer)) {
                    value += 0.7 * defense;
                    posReason = 'æ•Œæ–¹å…³é”®ä½ç½®';
                }
                
                for (const [starRow, starCol] of STAR_POSITIONS) {
                    if (i === starRow && j === starCol) {
                        value += 0.3;
                        posReason += posReason ? ', æ˜Ÿä½' : 'æ˜Ÿä½';
                    }
                }
                
                if (value > maxValue) {
                    maxValue = value;
                    reason = posReason || 'ä¸€èˆ¬ä½ç½®';
                }
            }
        }
    }
    
    return {
        value: maxValue,
        reason: reason
    };
}

// è¯„ä¼°æŠ€èƒ½5: å¼ å…´æœ
function evaluateSkill5(aiType) {
    const totalMoves = moveCount[0] + moveCount[1];
    const earlyGameBonus = Math.max(0, 1 - totalMoves / 30);
    const skill7Bonus = skill7Active && skill7Active[currentPlayer - 1] ? 0 : 0.5;
    const config = AI_CONFIGS[aiType] || UNIFIED_AI_CONFIG;
    const skill5Prob = (config.skillProbability && config.skillProbability.skill5) || 0.4;
    
    const value = (0.4 + earlyGameBonus * 0.3 + skill7Bonus) * skill5Prob;
    
    return {
        value: value,
        reason: `æ¸¸æˆæ—©æœŸä»·å€¼é«˜ï¼Œå¯æ¿€æ´»ä¿æ´ä¸Šé—¨æŠ€èƒ½`
    };
}

// è¯„ä¼°æŠ€èƒ½7: ä¿æ´ä¸Šé—¨
function evaluateSkill7(aiType) {
    let maxValue = 0;
    let bestColumn = 0;
    let reason = 'æ— åˆé€‚åˆ—å¯æ¸…é™¤';
    const config = AI_CONFIGS[aiType] || UNIFIED_AI_CONFIG;
    const aggression = config.aggression || 0.6;
    
    for (let col = 0; col < BOARD_SIZE; col++) {
        let value = 0;
        let enemyPieces = 0;
        let ownPieces = 0;
        
        for (let row = 0; row < BOARD_SIZE; row++) {
            if (board[row][col] !== 0) {
                if (board[row][col] === currentPlayer) {
                    ownPieces++;
                } else {
                    enemyPieces++;
                }
            }
        }
        
        value = (enemyPieces * 0.4 - ownPieces * 0.2) * aggression;
        
        if (value > maxValue) {
            maxValue = value;
            bestColumn = col;
            reason = `æ¸…é™¤ ${String.fromCharCode(65 + col)} åˆ—ï¼Œæ•Œæ–¹${enemyPieces}å­ï¼Œå·±æ–¹${ownPieces}å­`;
        }
    }
    
    return {
        value: maxValue,
        reason: reason
    };
}

// è¯„ä¼°æŠ€èƒ½9: ä¸¤æåè½¬
function evaluateSkill9(aiType) {
    const enemyPlayer = currentPlayer === 1 ? 2 : 1;
    let enemyPiecesCount = 0;
    const config = AI_CONFIGS[aiType] || UNIFIED_AI_CONFIG;
    const skill9Prob = (config.skillProbability && config.skillProbability.skill9) || 0.3;
    
    for (let i = 0; i < BOARD_SIZE; i++) {
        for (let j = 0; j < BOARD_SIZE; j++) {
            if (board[i][j] === enemyPlayer) {
                enemyPiecesCount++;
            }
        }
    }
    
    const value = (enemyPiecesCount > 0 ? 0.5 : 0) * skill9Prob;
    
    return {
        value: value,
        reason: enemyPiecesCount > 0 ? `æœ‰${enemyPiecesCount}ä¸ªæ•Œæ–¹æ£‹å­å¯è½¬æ¢` : 'æ— æ•Œæ–¹æ£‹å­å¯è½¬æ¢'
    };
}

// è¯„ä¼°æŠ€èƒ½11: æ“’æ“’æ‹¿æ‹¿
function evaluateSkill11(aiType) {
    const enemyPlayer = currentPlayer === 1 ? 2 : 1;
    const config = AI_CONFIGS[aiType] || UNIFIED_AI_CONFIG;
    const defense = config.defense || 0.6;
    
    if (skill1Active[enemyPlayer - 1] && !skill1Used[enemyPlayer - 1]) {
        return {
            value: 0.8 * defense,
            reason: 'æ•Œæ–¹é£æ²™èµ°çŸ³å·²æ¿€æ´»ï¼Œå¯å°é”'
        };
    }
    
    return {
        value: 0,
        reason: 'æ•Œæ–¹é£æ²™èµ°çŸ³æœªæ¿€æ´»'
    };
}

// è¯„ä¼°æŠ€èƒ½12: See You Again
function evaluateSkill12(aiType) {
    const ownRemovedPieces = removedPieces.filter(piece => piece.player === currentPlayer);
    const config = AI_CONFIGS[aiType] || UNIFIED_AI_CONFIG;
    const skill12Prob = (config.skillProbability && config.skillProbability.skill12) || 0.5;
    
    if (ownRemovedPieces.length === 0) {
        return {
            value: 0,
            reason: 'ä»€åˆ¹æµ·ä¸­æ²¡æœ‰æˆ‘æ–¹æ£‹å­'
        };
    }
    
    const value = (0.6 + ownRemovedPieces.length * 0.1) * skill12Prob;
    
    return {
        value: value,
        reason: `ä»€åˆ¹æµ·ä¸­æœ‰${ownRemovedPieces.length}ä¸ªæˆ‘æ–¹æ£‹å­ï¼Œå¯æ”¾å›å¹¶è·³è¿‡æ•Œæ–¹å›åˆ`
    };
}

// AIä½¿ç”¨æŠ€èƒ½
function useAISkill(skillNumber, aiType) {
    console.log(`AIä½¿ç”¨æŠ€èƒ½ ${skillNumber}`);
    
    switch (skillNumber) {
        case 1: useAISkill1(aiType); break;
        case 3: useAISkill3(aiType); break;
        case 5: 
            if (typeof useSkill5 === 'function') useSkill5();
            break;
        case 7: useAISkill7(aiType); break;
        case 9: 
            if (typeof useSkill9 === 'function') useSkill9();
            break;
        case 11: 
            if (typeof useSkill11 === 'function') useSkill11();
            break;
        case 12: 
            if (typeof useSkill12 === 'function') useSkill12();
            break;
    }
}

// AIä½¿ç”¨æŠ€èƒ½1: é£æ²™èµ°çŸ³
function useAISkill1(aiType) {
    console.log("AIä½¿ç”¨æŠ€èƒ½1: é£æ²™èµ°çŸ³");
    
    let bestPiece = null;
    let maxEnemyCount = 0;
    
    for (let i = 0; i < BOARD_SIZE; i++) {
        for (let j = 0; j < BOARD_SIZE; j++) {
            if (board[i][j] === currentPlayer) {
                const count = countEnemyPiecesInRange(i, j, SKILL_RANGE);
                if (count > maxEnemyCount) {
                    maxEnemyCount = count;
                    bestPiece = { row: i, col: j };
                }
            }
        }
    }
    
    if (bestPiece && maxEnemyCount > 0) {
        const enemyPlayer = currentPlayer === 1 ? 2 : 1;
        let removedCount = 0;
        
        for (let i = 0; i < BOARD_SIZE; i++) {
            for (let j = 0; j < BOARD_SIZE; j++) {
                if (board[i][j] === enemyPlayer) {
                    const distance = Math.abs(i - bestPiece.row) + Math.abs(j - bestPiece.col);
                    if (distance <= SKILL_RANGE) {
                        removedPieces.push({
                            player: enemyPlayer,
                            row: i,
                            col: j,
                            moveNumber: moveNumbers[i][j]
                        });
                        
                        board[i][j] = 0;
                        moveNumbers[i][j] = 0;
                        removedCount++;
                    }
                }
            }
        }
        
        if (removedCount > 0 && skill1RemoveSound) {
            skill1RemoveSound.currentTime = 0;
            skill1RemoveSound.play().catch(e => console.log("æŠ€èƒ½1éŸ³æ•ˆæ’­æ”¾å¤±è´¥:", e));
        }
        
        addActionLog(`ä½¿ç”¨é£æ²™èµ°çŸ³ï¼Œæ¸…é™¤${removedCount}ä¸ªæ•Œæ–¹æ£‹å­`, true);
        
        updateBackgroundMusicVolume();
        drawBoard();
        updateRemovedPiecesDisplay();
        
        skill1Used[currentPlayer - 1] = true;
        globalSkillsUsed[0] = true;
        
        finishSkill();
        switchPlayer();
    } else {
        const move = getBestMove(aiType);
        if (typeof placePiece === 'function') {
            placePiece(move.row, move.col);
        }
    }
}

// AIä½¿ç”¨æŠ€èƒ½3: åŠ›æ‹”å±±è¥¿
function useAISkill3(aiType) {
    console.log("AIä½¿ç”¨æŠ€èƒ½3: åŠ›æ‹”å±±è¥¿");
    
    const enemyPlayer = currentPlayer === 1 ? 2 : 1;
    let bestPosition = null;
    let maxValue = 0;
    
    for (let i = 0; i < BOARD_SIZE; i++) {
        for (let j = 0; j < BOARD_SIZE; j++) {
            if (board[i][j] === 0 && !isPositionBroken(i, j) && !isPositionBlocked(i, j)) {
                let value = 0;
                
                if (isImportantPosition(i, j, enemyPlayer)) {
                    value += 0.7;
                }
                
                for (const [starRow, starCol] of STAR_POSITIONS) {
                    if (i === starRow && j === starCol) {
                        value += 0.3;
                    }
                }
                
                if (value > maxValue) {
                    maxValue = value;
                    bestPosition = { row: i, col: j };
                }
            }
        }
    }
    
    if (bestPosition) {
        if (board[bestPosition.row][bestPosition.col] !== 0) {
            removedPieces.push({
                player: board[bestPosition.row][bestPosition.col],
                row: bestPosition.row,
                col: bestPosition.col,
                moveNumber: moveNumbers[bestPosition.row][bestPosition.col]
            });
            
            board[bestPosition.row][bestPosition.col] = 0;
            moveNumbers[bestPosition.row][bestPosition.col] = 0;
        }
        
        brokenPositions.push({row: bestPosition.row, col: bestPosition.col});
        
        if (brokenSound) {
            brokenSound.currentTime = 0;
            brokenSound.play().catch(e => console.log("æ‘”åéŸ³æ•ˆæ’­æ”¾å¤±è´¥:", e));
        }
        
        addActionLog(`ä½¿ç”¨åŠ›æ‹”å±±è¥¿ï¼Œæ‘”åä½ç½® ${String.fromCharCode(65 + bestPosition.col)}${bestPosition.row + 1}`, true);
        
        updateBackgroundMusicVolume();
        drawBoard();
        updateRemovedPiecesDisplay();
        
        skill3Used[currentPlayer - 1] = true;
        globalSkillsUsed[2] = true;
        
        finishSkill();
        switchPlayer();
    } else {
        const move = getBestMove(aiType);
        if (typeof placePiece === 'function') {
            placePiece(move.row, move.col);
        }
    }
}

// AIä½¿ç”¨æŠ€èƒ½7: ä¿æ´ä¸Šé—¨
function useAISkill7(aiType) {
    console.log("AIä½¿ç”¨æŠ€èƒ½7: ä¿æ´ä¸Šé—¨");
    
    let bestColumn = 0;
    let maxValue = 0;
    
    for (let col = 0; col < BOARD_SIZE; col++) {
        let value = 0;
        let enemyPieces = 0;
        let ownPieces = 0;
        
        for (let row = 0; row < BOARD_SIZE; row++) {
            if (board[row][col] !== 0) {
                if (board[row][col] === currentPlayer) {
                    ownPieces++;
                } else {
                    enemyPieces++;
                }
            }
        }
        
        value = enemyPieces * 0.4 - ownPieces * 0.2;
        
        if (value > maxValue) {
            maxValue = value;
            bestColumn = col;
        }
    }
    
    if (maxValue > 0) {
        let removedCount = 0;
        for (let i = 0; i < BOARD_SIZE; i++) {
            if (board[i][bestColumn] !== 0) {
                removedPieces.push({
                    player: board[i][bestColumn],
                    row: i,
                    col: bestColumn,
                    moveNumber: moveNumbers[i][bestColumn]
                });
                
                board[i][bestColumn] = 0;
                moveNumbers[i][bestColumn] = 0;
                removedCount++;
            }
        }
        
        if (removedCount > 0 && skill7RemoveSound) {
            skill7RemoveSound.currentTime = 0;
            skill7RemoveSound.play().catch(e => console.log("æŠ€èƒ½7éŸ³æ•ˆæ’­æ”¾å¤±è´¥:", e));
        }
        
        addActionLog(`ä½¿ç”¨ä¿æ´ä¸Šé—¨ï¼Œæ¸…é™¤ ${String.fromCharCode(65 + bestColumn)} åˆ—æ‰€æœ‰æ£‹å­`, true);
        
        updateBackgroundMusicVolume();
        drawBoard();
        updateRemovedPiecesDisplay();
        
        skill7Used[currentPlayer - 1] = true;
        globalSkillsUsed[6] = true;
        
        finishSkill();
        switchPlayer();
    } else {
        const move = getBestMove(aiType);
        if (typeof placePiece === 'function') {
            placePiece(move.row, move.col);
        }
    }
}

// è¾…åŠ©å‡½æ•°ï¼šè®¡ç®—èŒƒå›´å†…æ•Œæ–¹æ£‹å­æ•°é‡
function countEnemyPiecesInRange(row, col, range) {
    const enemyPlayer = currentPlayer === 1 ? 2 : 1;
    let count = 0;
    
    for (let i = 0; i < BOARD_SIZE; i++) {
        for (let j = 0; j < BOARD_SIZE; j++) {
            if (board[i][j] === enemyPlayer) {
                const distance = Math.abs(i - row) + Math.abs(j - col);
                if (distance <= range) {
                    count++;
                }
            }
        }
    }
    
    return count;
}

// è¾…åŠ©å‡½æ•°ï¼šåˆ¤æ–­ä½ç½®æ˜¯å¦é‡è¦ï¼ˆèƒ½å½¢æˆè¿çº¿ï¼‰
function isImportantPosition(row, col, player) {
    board[row][col] = player;
    
    let isImportant = false;
    
    const directions = [
        [0, 1],  // æ¨ª
        [1, 0],  // ç«–
        [1, 1],  // å·¦ä¸Šåˆ°å³ä¸‹
        [1, -1]  // å³ä¸Šåˆ°å·¦ä¸‹
    ];
    
    for (const [dx, dy] of directions) {
        let count = 1;
        
        for (let i = 1; i < 5; i++) {
            const newRow = row + dx * i;
            const newCol = col + dy * i;
            
            if (newRow >= 0 && newRow < BOARD_SIZE && 
                newCol >= 0 && newCol < BOARD_SIZE && 
                board[newRow][newCol] === player) {
                count++;
            } else {
                break;
            }
        }
        
        for (let i = 1; i < 5; i++) {
            const newRow = row - dx * i;
            const newCol = col - dy * i;
            
            if (newRow >= 0 && newRow < BOARD_SIZE && 
                newCol >= 0 && newCol < BOARD_SIZE && 
                board[newRow][newCol] === player) {
                count++;
            } else {
                break;
            }
        }
        
        if (count >= 3) {
            isImportant = true;
            break;
        }
    }
    
    board[row][col] = 0;
    
    return isImportant;
}

// è·å–æœ€ä½³è½å­ä½ç½®
function getBestMove(aiType) {
    const enemyPlayer = currentPlayer === 1 ? 2 : 1;
    
    // æ£€æŸ¥æ˜¯å¦æœ‰ç«‹å³è·èƒœçš„æœºä¼š
    let winningMove = findWinningMove(currentPlayer);
    if (winningMove) {
        winningMove.reason = 'ç«‹å³è·èƒœæœºä¼š';
        return winningMove;
    }
    
    // æ£€æŸ¥æ˜¯å¦éœ€è¦é˜»æ­¢å¯¹æ‰‹è·èƒœ
    let blockingMove = findWinningMove(enemyPlayer);
    if (blockingMove) {
        blockingMove.reason = 'é˜»æ­¢å¯¹æ‰‹è·èƒœ';
        return blockingMove;
    }
    
    return getHardMove(aiType);
}

// å¯»æ‰¾è·èƒœä½ç½®
function findWinningMove(player) {
    for (let i = 0; i < BOARD_SIZE; i++) {
        for (let j = 0; j < BOARD_SIZE; j++) {
            if (board[i][j] === 0 && !isPositionBroken(i, j) && !isPositionBlocked(i, j)) {
                board[i][j] = player;
                if (checkWin(i, j, player)) {
                    board[i][j] = 0;
                    return { 
                        row: i, 
                        col: j,
                        reason: 'è·èƒœä½ç½®'
                    };
                }
                board[i][j] = 0;
            }
        }
    }
    return null;
}

// ç®€å•AIï¼šéšæœºè½å­
function getEasyMove(aiType) {
    const emptyPositions = [];
    
    for (let i = 0; i < BOARD_SIZE; i++) {
        for (let j = 0; j < BOARD_SIZE; j++) {
            if (board[i][j] === 0 && !isPositionBroken(i, j) && !isPositionBlocked(i, j)) {
                emptyPositions.push({ row: i, col: j });
            }
        }
    }
    
    if (emptyPositions.length > 0) {
        const randomIndex = Math.floor(Math.random() * emptyPositions.length);
        const move = emptyPositions[randomIndex];
        move.reason = 'éšæœºé€‰æ‹©ä½ç½®';
        return move;
    }
    
    return null;
}

// å›°éš¾AIï¼šè¯„ä¼°å‡½æ•°
function getHardMove(aiType) {
    const scoredPositions = [];
    const config = AI_CONFIGS[aiType] || UNIFIED_AI_CONFIG;
    
    for (let i = 0; i < BOARD_SIZE; i++) {
        for (let j = 0; j < BOARD_SIZE; j++) {
            if (board[i][j] === 0 && !isPositionBroken(i, j) && !isPositionBlocked(i, j)) {
                let score = calculatePositionScore(i, j, aiType);
                score += evaluateFuturePotential(i, j, currentPlayer, 2, aiType);
                scoredPositions.push({ row: i, col: j, score: score });
            }
        }
    }
    
    if (scoredPositions.length > 0) {
        scoredPositions.sort((a, b) => b.score - a.score);
        const bestMove = scoredPositions[0];
        bestMove.reason = `æœ€é«˜åˆ†ä½ç½®`;
        return bestMove;
    }
    
    return getEasyMove(aiType);
}

// è¯„ä¼°æœªæ¥æ½œåŠ›
function evaluateFuturePotential(row, col, player, depth, aiType) {
    if (depth <= 0) return 0;
    
    let potentialScore = 0;
    const config = AI_CONFIGS[aiType] || UNIFIED_AI_CONFIG;
    const aggression = config.aggression || 0.6;
    const defense = config.defense || 0.6;
    
    board[row][col] = player;
    
    const enemyPlayer = player === 1 ? 2 : 1;
    
    if (hasLiveThree(player)) {
        potentialScore += 50 * depth * aggression;
    }
    
    if (hasFourInRow(player)) {
        potentialScore += 100 * depth * aggression;
    }
    
    if (depth > 1) {
        let bestEnemyResponse = 0;
        
        for (let i = 0; i < BOARD_SIZE; i++) {
            for (let j = 0; j < BOARD_SIZE; j++) {
                if (board[i][j] === 0 && !isPositionBroken(i, j) && !isPositionBlocked(i, j)) {
                    const enemyScore = evaluateFuturePotential(i, j, enemyPlayer, depth - 1, aiType);
                    if (enemyScore > bestEnemyResponse) {
                        bestEnemyResponse = enemyScore;
                    }
                }
            }
        }
        
        potentialScore -= bestEnemyResponse * 0.5 * defense;
    }
    
    board[row][col] = 0;
    
    return potentialScore;
}

// è®¡ç®—ä½ç½®åˆ†æ•°
function calculatePositionScore(row, col, aiType) {
    let score = 0;
    const config = AI_CONFIGS[aiType] || UNIFIED_AI_CONFIG;
    const aggression = config.aggression || 0.6;
    const defense = config.defense || 0.6;
    const randomness = config.randomness || 0.2;
    
    const center = BOARD_SIZE / 2;
    const distanceFromCenter = Math.sqrt(Math.pow(row - center, 2) + Math.pow(col - center, 2));
    score += (BOARD_SIZE - distanceFromCenter) * 2;
    
    for (let i = Math.max(0, row - 2); i <= Math.min(BOARD_SIZE - 1, row + 2); i++) {
        for (let j = Math.max(0, col - 2); j <= Math.min(BOARD_SIZE - 1, col + 2); j++) {
            if (board[i][j] === currentPlayer) {
                score += 10 * aggression;
            } else if (board[i][j] !== 0) {
                score += 5 * defense;
            }
        }
    }
    
    for (const [starRow, starCol] of STAR_POSITIONS) {
        if (row === starRow && col === starCol) {
            score += 15;
        }
    }
    
    score += Math.random() * 5 * randomness;
    
    return score;
}

// æ£€æŸ¥æ˜¯å¦æœ‰æ´»ä¸‰
function hasLiveThree(player) {
    for (let i = 0; i < BOARD_SIZE; i++) {
        for (let j = 0; j < BOARD_SIZE; j++) {
            if (board[i][j] === player) {
                const directions = [[0,1], [1,0], [1,1], [1,-1]];
                
                for (const [dx, dy] of directions) {
                    let count = 1;
                    let emptyEnds = 0;
                    
                    for (let k = 1; k < 4; k++) {
                        const newRow = i + dx * k;
                        const newCol = j + dy * k;
                        
                        if (newRow >= 0 && newRow < BOARD_SIZE && newCol >= 0 && newCol < BOARD_SIZE) {
                            if (board[newRow][newCol] === player) {
                                count++;
                            } else if (board[newRow][newCol] === 0) {
                                emptyEnds++;
                                break;
                            } else {
                                break;
                            }
                        } else {
                            break;
                        }
                    }
                    
                    for (let k = 1; k < 4; k++) {
                        const newRow = i - dx * k;
                        const newCol = j - dy * k;
                        
                        if (newRow >= 0 && newRow < BOARD_SIZE && newCol >= 0 && newCol < BOARD_SIZE) {
                            if (board[newRow][newCol] === player) {
                                count++;
                            } else if (board[newRow][newCol] === 0) {
                                emptyEnds++;
                                break;
                            } else {
                                break;
                            }
                        } else {
                            break;
                        }
                    }
                    
                    if (count === 3 && emptyEnds >= 2) {
                        return true;
                    }
                }
            }
        }
    }
    
    return false;
}

// æ£€æŸ¥æ˜¯å¦æœ‰å››è¿
function hasFourInRow(player) {
    for (let i = 0; i < BOARD_SIZE; i++) {
        for (let j = 0; j < BOARD_SIZE; j++) {
            if (board[i][j] === player) {
                const directions = [[0,1], [1,0], [1,1], [1,-1]];
                
                for (const [dx, dy] of directions) {
                    let count = 1;
                    
                    for (let k = 1; k < 5; k++) {
                        const newRow = i + dx * k;
                        const newCol = j + dy * k;
                        
                        if (newRow >= 0 && newRow < BOARD_SIZE && newCol >= 0 && newCol < BOARD_SIZE) {
                            if (board[newRow][newCol] === player) {
                                count++;
                            } else {
                                break;
                            }
                        } else {
                            break;
                        }
                    }
                    
                    for (let k = 1; k < 5; k++) {
                        const newRow = i - dx * k;
                        const newCol = j - dy * k;
                        
                        if (newRow >= 0 && newRow < BOARD_SIZE && newCol >= 0 && newCol < BOARD_SIZE) {
                            if (board[newRow][newCol] === player) {
                                count++;
                            } else {
                                break;
                            }
                        } else {
                            break;
                        }
                    }
                    
                    if (count >= 4) {
                        return true;
                    }
                }
            }
        }
    }
    
    return false;
}

// è·å–AIåç§°
function getAIName(aiType) {
    const aiNames = {
        'black-zhangcheng': 'é»‘å¼ å‘ˆ',
        'black-skill5': 'é»‘æŠ€èƒ½äº”',
        'black-ziqi': 'é»‘å­æ£‹',
        'black-wangjinbao': 'é»‘ç‹é‡‘å®',
        'white-zhangcheng': 'ç™½å¼ å‘ˆ',
        'white-skill5': 'ç™½æŠ€èƒ½äº”',
        'white-ziqi': 'ç™½å­æ£‹',
        'white-wangjinbao': 'ç™½ç‹é‡‘å®'
    };
    
    return aiNames[aiType] || 'AI';
}

// æ£€æŸ¥æ˜¯å¦æ˜¯AI
function isAI(playerType) {
    return playerType && (playerType.includes('zhangcheng') || 
                         playerType.includes('skill5') || 
                         playerType.includes('ziqi') || 
                         playerType.includes('wangjinbao'));
}

// åœ¨åˆ‡æ¢ç©å®¶æ—¶æ£€æŸ¥æ˜¯å¦éœ€è¦AIç§»åŠ¨
function checkForAIMove() {
    const aiType = playerTypes[currentPlayer - 1];
    
    if ((skill12TimerActive || skill2TimerActive) && isAI(aiType)) {
        aiThinking[aiType] = false;
        updateAIThinkingLog("AIå›åˆè¢«æŠ€èƒ½è·³è¿‡ï¼Œæ— éœ€æ€è€ƒ");
        return;
    }
    
    if (gameStarted && !gameOver && isAI(aiType)) {
        setTimeout(() => {
            aiMakeMove();
        }, 300);
    }
}

// ä¿®æ”¹ç°æœ‰çš„switchPlayerå‡½æ•°ï¼Œæ·»åŠ AIæ£€æŸ¥
if (typeof switchPlayer === 'function') {
    const originalSwitchPlayer = switchPlayer;
    switchPlayer = function() {
        originalSwitchPlayer.apply(this, arguments);
        checkForAIMove();
    };
}

// ä¿®æ”¹ç°æœ‰çš„initGameå‡½æ•°ï¼Œæ·»åŠ AIåˆå§‹åŒ–
if (typeof initGame === 'function') {
    const originalInitGame = initGame;
    initGame = function() {
        originalInitGame.apply(this, arguments);
        initAI();
    };
}

// ä¿®æ”¹ç°æœ‰çš„handleRestartRequestå‡½æ•°ï¼Œé‡ç½®AIçŠ¶æ€
if (typeof handleRestartRequest === 'function') {
    const originalHandleRestartRequest = handleRestartRequest;
    handleRestartRequest = function() {
        originalHandleRestartRequest.apply(this, arguments);
        
        for (const aiType in aiThinking) {
            aiThinking[aiType] = false;
        }
        for (const aiType in aiDecisionHistory) {
            aiDecisionHistory[aiType] = [];
        }
        
        const aiThinkingContainer = document.getElementById('ai-thinking-container');
        if (aiThinkingContainer) {
            aiThinkingContainer.style.display = 'none';
        }
    };
}

// é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–AI
window.addEventListener('load', function() {
    console.log('é¡µé¢å·²åŠ è½½ï¼Œåˆå§‹åŒ–AI...');
    setTimeout(() => {
        initAI();
    }, 100);
});